# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'StartingLook.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
import smtplib, ssl
import ast #lets parse string representations of lists to lists
import ctypes
from datetime import datetime #can find date
from PyQt5.QtWidgets import* #import all widgets
from PyQt5 import QtCore


#WIDGETS
# Import QApplication and the required widgets from PyQt5.QtWidgets
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication #to start
from PyQt5.QtWidgets import QMainWindow #provides a framework for building an application's user interface. 
from PyQt5.QtWidgets import QWidget #widget that pretty much all pyqt5 interfaces is based on as the central widget. It is what recieves events (ex. click, keydown)
from PyQt5.QtWidgets import QDesktopWidget #gives access to methods to get centre point of desktop

from PyQt5.QtWidgets import QAction 

from PyQt5.QtWidgets import QStatusBar
from PyQt5.QtWidgets import QMenuBar

class Ui_MainWindow(QMainWindow):
    '''
    QMainWindow Layout
    ______________________________________
   |__Menu Bar____________________________| #dropdown menu selections file, edit, etc
   |_______________ToolBars_______________| #makes buttons that give users access to functions, typcially just visual buttons for menu bar quick access
   |   __________Dock Windows__________   | #creates side view next to the central widget
   |  |                                |  |
   |  |                                |  |
   |  |          Cental Widget         |  | #the main widget, which is almost always QWidget to recieve the user's inputs
   |  |                                |  |
   |  |________________________________|  |
   |______________________________________|
   |___Status Bar_________________________| #can add temperary or permanent messages
    '''
    def __init__(self):
        super().__init__() #initialize the QMainWindow
        self.windowTitleSetter('Test Taker') #call to name the default

        self.resize(597, 50) #set default size

        self.makeStoringArrays() #call to make empty arrays that store instance variables so their data can be referenced

        self.makeCentralWidget() #make the central widget and central layout
        self.makeCentralScroll() #calls to make central layout able to scroll
        self.addToCentralScroll() #add the content inside of the scroll area

        self.makeMenuBar() #call to make menuBar
        self.makeStatusBar() #call to make status bar

        self.moveToCentre()#call to make cetnered
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SET WINDOW TITLE
    def windowTitleSetter(self, title):
        self.setWindowTitle(title) #name the mainWindow with the specified title

    #-------------------------------------------------
    def makeStoringArrays(self):
        self.lineEditsArray = []#make arrays to store instance varaibles to
        self.checkBoxArray = []

    #MOVE TO CENTRE
    def moveToCentre(self):
        self.rectangleInterface = self.frameGeometry() #calls frame geometry
        self.centerPoint = QDesktopWidget().availableGeometry().center() #which has the the ability to find the centre point of the desktop
        self.rectangleInterface.moveCenter(self.centerPoint) #following 2 lines move it to the centre point
        self.move(self.rectangleInterface.topLeft())

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #Central Widget
    def makeCentralWidget(self):
        self.centralWidget = QWidget() #define qWidget as the central widget, (accepts input)
        self.verticalLayoutForScroll = QtWidgets.QVBoxLayout(self.centralWidget) #make a verticle layout so the scrollArea widget can be placed in a layout, (needs to be entire, so this will only contain one container)
    
    #Scroll vert. layout which is actual main layout
    def makeCentralScroll(self):
        self.scrollArea = QtWidgets.QScrollArea(self.centralWidget) #set the central Qwidget to a scroll area which allows for the user to scroll if window is too small
        self.scrollArea.setWidgetResizable(True) #allow for the scroll area to be resized... necessary as adding more into the scroll area
        #now there a scroll area inside of the uppermost vertical layout that will recieve input scroll input from central widget, Qwidget

        self.scrollAreaWidgetContents = QtWidgets.QWidget() #defining what is in scroll area... which is the QWidget, which accepts user input, however Qwidget still has to be defined as central above to receive user input for the scroll
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 577, 207)) #set intial geometry of scroll area

        self.mainVerticalLayout = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents) #now need to put not technically the main layout, but the layout everything is going to be placed in since everything has to be inside the scroll area.
    
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #ADD TO SCROLL CONTENTS
    def addToCentralScroll(self):
        self.makeQuestionButtons() #add the question making buttons
        self.addScrollContentsToScrollWidget() #updates the contents from the object to the widget
    
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #ADD NEW QUESTION BUTTONS
    def makeQuestionButtons(self):
        self.searchForFileButton = QtWidgets.QPushButton('Select Test File', self.scrollAreaWidgetContents) #from the QtWidgets library use push button to make a new button with the string as its text
        self.mainVerticalLayout.addWidget(self.searchForFileButton) #add that button to the main vertical layout

        self.searchForFileButton.clicked.connect(self.searchFileEventHandler) #if that button is clicked, call the event handler

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #Event handler for finding file
    def searchFileEventHandler(self):
        try: #if user does not open a file, and instead closes or selects invalid file, going to cause error
            self.openDialogBox() #call to open the file selector
            self.makeTest() #call to make the test now that a file has been chosen to read

            self.openFileAction.setDisabled(True) #gray out / disable the open file
            self.submitFileAction.setDisabled(False) #un gray out / disable the submit

            self.searchForFileButton.setVisible(False) #turn off the buttons visibility
            self.resize(597, 500) #resize main window
            self.moveToCentre() #now that it has been resized, move it back to the center
        except Exception:
            self.statusBar().showMessage('Invalid File Selected', 5000) #show that in the statusbar

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #DIALOG BOX OPENER AND RETRIEVE ANS
    def openDialogBox(self):
        filename = QFileDialog.getOpenFileName()
        path = filename[0]

        with open(path, "r") as f:
            oneLineOfData = (f.readlines()) #reads the file with line by line setting fileData to list where each line is element and remove the newline char
            oneLineOfDataString = str(oneLineOfData[0]) #take the 0 index of the list that was just made make a variable that turns it into a string
            File = oneLineOfDataString.split("|") #split the oneLineOf data up into a string starting at each new '|' character

            #set variables to each line so can be reference easier and simplify
            self.title = File[0] #fine keeping these as strings of the the x index of file
            self.email = File[1]

            questionType = File[2] #store string of file index 2
            self.questionType = ast.literal_eval(questionType) #parse into list

            questionAsked = File[3] #store string of file index 3
            self.questionAsked = ast.literal_eval(questionAsked) #parse into list

            weighting = File[4] #store string of file index 4
            self.weighting = ast.literal_eval(weighting) #parse into a list
            self.totalScore = sum(self.weighting) #find the sum of all the weighting to make a total

            optionAndAnsListStr = File[5] #creating string var = to index 5
            self.optionAndAnsList = ast.literal_eval(optionAndAnsListStr) #parse that to a list and store to global

            correctCheckBox = File[6] #store to str
            self.correctCheckBox = ast.literal_eval(correctCheckBox) #parse into list for global

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #MAKE TEST
    def makeTest(self):
        self.makeDefaultLayout() #makes default layout and adds top of page stuff

        for index, i in enumerate(self.questionType): #for each element in question type, enum so can access both i to compare and index to
            if i == 'MC': #if the question type is multi
                self.addMultiQuestion(index) #then call to make a multiple choice question of that index
            elif i == 'SA' or i == 'LA': #otherwise if its short
                self.addShortQuestion(index) #then make a short question

        self.mainVerticalLayout.addLayout(self.testLayout) #add the layout to the main layout
        self.makeSubmitButton() #call to add the submit button
    
    #SUBMIT BUTTON AT BOTTOM
    def makeSubmitButton(self): 
        self.submitButton = QtWidgets.QPushButton('Submit', self.scrollAreaWidgetContents) #make a new button
        self.submitButton.clicked.connect(lambda: self.storeData()) #call to store data if its clicked
        self.mainVerticalLayout.addWidget(self.submitButton)#add ot to the main layout

    #MAKE THE INTIAL DEFAULT LAYOUT
    def makeDefaultLayout(self):
        self.testLayout = QtWidgets.QVBoxLayout() #make a new vertical layout
        
        self.titleLabel = QtWidgets.QLabel(self.title,self.centralWidget) #make a new label with the title from the file
        self.titleLabel.setAlignment(QtCore.Qt.AlignCenter) #style it so it is centered
        self.titleLabel.setStyleSheet("font: bold") #make title bold
        self.testLayout.addWidget(self.titleLabel) #add it to the vertical layout

        self.formLayout = QtWidgets.QFormLayout() #make a form layout

        self.enterNameLabel = QtWidgets.QLabel('Enter Name:',self.centralWidget) #make new label
        self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.enterNameLabel) #add label to the form layou

        self.enterNameLineEdit = QtWidgets.QLineEdit(self.centralWidget) #make a new line edt
        self.lineEditsArray.append(self.enterNameLineEdit) #append that to the line edit array
        self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.enterNameLineEdit) #add the line edit to the form
        self.testLayout.addLayout(self.formLayout) #add the form to the test layout

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #QUESTIONS
    #MULTI
    def addMultiQuestion(self, index):
        self.questionLayout = QtWidgets.QVBoxLayout() 
        self.groupBox = QtWidgets.QGroupBox('Question ' +str(index+1) + ':  /' + str(self.weighting[index]), self.centralWidget) #make group box with title as Question x - /weightOfQuestion 

        self.groupBoxLayout = QtWidgets.QVBoxLayout(self.groupBox) #making groupbox inner layout

        self.question1 = QtWidgets.QLabel(self.questionAsked[index], self.groupBox) # make new label with the text being the question asked for that question (index)
        self.groupBoxLayout.addWidget(self.question1) #add the label to the group box layout

        self.multiChoiceOptionsForm = QtWidgets.QFormLayout() #make a new form

        nestedCheckBoxArray = [] #make new array to append to, then be appended to the checkBox set 2d array
        for indexTrack, i in enumerate(self.optionAndAnsList[index]): #for i in the option / ans list @ the current index, enum to track index too
                self.checkBox = QtWidgets.QCheckBox("Option"+ str(indexTrack+1)+ ":", self.groupBox) #WILL MAKE FOR I IN optionAndAnsList... adding one per option
                self.multiChoiceOptionsForm.setWidget(indexTrack, QtWidgets.QFormLayout.LabelRole, self.checkBox) #add it to the form at position index
                nestedCheckBoxArray.append(self.checkBox)#add the instance of checkBox to the array

                self.checkBoxAnsLabel = QtWidgets.QLabel(i,self.groupBox) #make a new label with the option text or i
                self.multiChoiceOptionsForm.setWidget(indexTrack, QtWidgets.QFormLayout.FieldRole, self.checkBoxAnsLabel) #add to form

        self.checkBoxArray.append(nestedCheckBoxArray)#append the nested list to list of sets of checkBoxes

        self.groupBoxLayout.addLayout(self.multiChoiceOptionsForm) #add form to group box
        self.questionLayout.addWidget(self.groupBox) #add groupbox to quest layout
        
        self.testLayout.addLayout(self.questionLayout) #add quest layout to test layout

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SHORT
    def addShortQuestion(self, index):
        self.questionLayout = QtWidgets.QVBoxLayout() #make new layout
        self.groupBox = QtWidgets.QGroupBox('Question' +str(index+1) + ':  /' + str(self.weighting[index]), self.centralWidget) #make new group box with title being the question num and its weighting

        self.groupBoxLayout = QtWidgets.QVBoxLayout(self.groupBox) #make group box inner layout

        self.questionLabel = QtWidgets.QLabel(self.questionAsked[index], self.groupBox) # make new label with the text being the question asked for that question (index)
        self.groupBoxLayout.addWidget(self.questionLabel) #add the label to the group box

        self.answerLineEdit = QtWidgets.QLineEdit(self.groupBox) #make a new line edit that belongs to the group box
        self.lineEditsArray.append(self.answerLineEdit) #append that to the line edit array
        self.groupBoxLayout.addWidget(self.answerLineEdit) #add it to the group box

        self.questionLayout.addWidget(self.groupBox) #add the group box to question layout
        self.testLayout.addLayout(self.questionLayout) #add the question layout to the test layout
    

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #STORE DATA
    def storeData(self):
        submittedLineEdits = self.retreieveLineEdits() #call to retrieve the text of all line edits as array
        self.name = submittedLineEdits.pop(0) #remove the first element of list which is name since it is not to  be compared and store to var

        submittedCheckBoxes = self.retreiveCheckBoxes() #call to recieve the state of all checkboxes as 2d array

        self.compareData(submittedLineEdits, submittedCheckBoxes) #call to compare the now stored data to the answers

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #RETURN ALL CHECKBOXES
    def retreiveCheckBoxes(self):
        checkBoxTrueOrFalse = [] #make a list to append to
        for checkBoxSet in self.checkBoxArray: #for each list in the the 2d array
            nestedCheckBoxSet = [] #make a list to store to / redfine the list
            for checkBoxObj in checkBoxSet: #for each check box obj in that list
                nestedCheckBoxSet.append(self.checkIfBoxChecked(checkBoxObj)) #append it the box obj is check or not to the nested check box set

            checkBoxTrueOrFalse.append(nestedCheckBoxSet) #now that nestedCheckBoxSet has been appended to, append that list to the main list

        return checkBoxTrueOrFalse #return the list

    def checkIfBoxChecked(self, checkBoxInst):        
        return checkBoxInst.isChecked() #returns true or false if it is checked

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #LINE EDIT RETREIVER
    def retreieveLineEdits(self):
        storedLineEdits = [] #make a list to append to
        for lineEdit in self.lineEditsArray: #for each line edit in the array
            textFound = self.getLineText(lineEdit) #call to return the text and set it to a variable
            storedLineEdits.append(textFound) #then append that variable to the data list

        return storedLineEdits #return the dataList

    def getLineText(self, lineEditInst):
        return lineEditInst.text() #returns the text of what that line edit is
    
    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #COMPARE DATA
    def compareData(self, lineEdits, checkBoxes):
        self.playerScore = 0 #make a score to add to        
        mutliChoiceCounter = 0 #using to track checkbox index instead of index of question type because not all questions will have check boxes
        shortAnsCounter = 0 #same for short ans
        #still need index for weighting though

        emailContent = str(self.name)+ ' Wrote ' + (self.title) + ' On... ' #Make a new str var called email content and add more strings to it

        timeStamp = self.getDate() #call to get the date
        emailContent += timeStamp + '\n' #add the date to email content and a new line

        for index, question in enumerate(self.questionType): #for each question in the question type list
            if question == "MC":
                if checkBoxes[mutliChoiceCounter] == self.correctCheckBox[index]: #if the indexes of the submitted and the answers are =, mutlichoice counter as index but index of multi chocie questions made because thats how many checkboxes will be made
                    self.playerScore += self.weighting[index] #if it is add the weighting to the total score...
                    emailContent += ('Question '+ str(index+1) + ': ' + self.questionAsked[index]+ '- Correct\n') #and add they got the question correct to the email
                else:
                    emailContent += ('Question '+ str(index+1) + ': ' + self.questionAsked[index]+ '- Incorrect\n') #otherwise add they got the question wrong

                mutliChoiceCounter += 1 #add to the count

            elif question == "SA":
                correctAnsFound = False
                for answer in self.optionAndAnsList[index]: #for each of the possible answers in the list of the array / per question (specified with index)
                    if lineEdits[shortAnsCounter] == answer: #check if the submitted line edit is equal to current answer. (index is + one because first line edit is Name)
                        self.playerScore += self.weighting[index] #if it is add the weighting to the total score...
                        correctAnsFound = True #set true that it found a correct ans

                if correctAnsFound == True: #once it goes through the for loop if it ever matched a correct answer, then...
                    emailContent += ('Question  '+ str(index+1) + ': ' + self.questionAsked[index]+ '- Correct\n') #add that they answered question correctly to email
                else: #otherwise...
                    emailContent += ('Question  '+ str(index+1) + ': ' + self.questionAsked[index]+ '- Incorrect\n') #add that they answered question correctly to email#add to the email that they got the question wrong
                shortAnsCounter += 1 #add to count

            elif question == "LA":
                self.totalScore -= self.weighting[index] #remove the weighting from the total score so it is not included in the test
                emailContent += ('Question  '+ str(index+1) + ': ' + self.questionAsked[index]+ '- To be graded out of ' + str(self.weighting[index]) + '\n') #add the question and what it is to be graded out of
                emailContent += (self.name + "'s Response:\n") #add response label
                emailContent += (str(lineEdits[shortAnsCounter])) + '\n'#add the response

                shortAnsCounter += 1
                #add the text to the email
        
        emailContent += '\nOverall Score:' + str(self.playerScore)+ '/' +str(self.totalScore)  #add a line of the overall score
        ctypes.windll.user32.MessageBoxW(0, ("Your Mark was: " +str(self.playerScore)+ '/' +str(self.totalScore)), "Result", 1) #makes message box to display score to user
        
        self.sendEmail(emailContent) #call to send the email with given text
        self.writeToFile(emailContent) #call to add to a file

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #GET TIMESTAMP    
    def getDate(self):
        currentDate = datetime.now() #calls to get current date
        timeUnits =  currentDate.strftime("%B:/%m/%Y at %H:%M:%S") ##now calls for month year hour etc. of the date
        return timeUnits
    
    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SEND AN EMAIL WITH GIVEN TEXT
    def sendEmail(self,text):
        subject = str(self.name) + "'s " +str(self.title) + " Test Score" #create a string that is the subject
        self.emailText = 'Subject: {}\n\n{}'.format(subject, text) #set the subject of self.emailText to the subjec above
    
        try: #enter try if port is blocked or invalid reieve email
            sender, password = 'grahamTestMaker@gmail.com', 'TestMakePassword1' #t #the sender username then password MUST GMAIL ACCOUNT, dont hack me pls :)

            recieve = self.email #define the reciever...
            message =  self.emailText #the message
            port = 465 #standard ssl port - router could block ssl port
        
            context = ssl.create_default_context()
            self.statusBar().showMessage('Sending Results...', 5000) #show that in the statusbar that it is sending, but will quickly be replaced by sent 

            with smtplib.SMTP_SSL("smtp.gmail.com", port, context=context) as server: #access the gmail server
                server.login(sender, password) #login to gmail account
                server.sendmail(sender, recieve, message) #send mail
            
            self.statusBar().showMessage(('Results Sent to ' + str(self.email)),5000) #once above is completed will display sent

        except Exception:
            self.statusBar().showMessage('Port '+str(port)+ ' is blocked or invalid gmail account',5000) #otherwise indicate that the port is blocked or the email is invalid
    
    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #WRITE RESPONSE TO FILE
    def writeToFile(self, text):
        answerFile = open("GrahamAnswerSaveFile.txt", "a") #also going to open the file / make it if it has not been made and (a for) append the last equation
        answerFile.truncate(0) #truncate erases content of text file
        answerFile.write(text) #then append the arguement text
        answerFile.write('\n') #make a new line
        answerFile.close()#closes file after writing to it

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SCROLL SETTER THAT ADDS CONTENTS TO WIDGET
    def addScrollContentsToScrollWidget(self):
        self.scrollArea.setWidget(self.scrollAreaWidgetContents) #add the contents (ex. buttons, line edit) to the scroll area
        self.verticalLayoutForScroll.addWidget(self.scrollArea) #add the scroll area to the veritcal layout
        self.setCentralWidget(self.centralWidget) #now that scroll has its contents, contents need to interact and receive input, so set the central widget to Qwidget

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #MAKE MENUBAR
    def makeMenuBar(self):
        self.menuBar = QMenuBar() #make a new menubar
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 602, 21)) #set default size

        self.addMenus() #add menus to the menubar
        self.menuBarSetter() #call the mutator / setter to set it

        self.addFileActionsToMenu() #add the File actions (essentially buttons) in the menu
    
    #MENUS
    def addMenus(self):
        self.menuFile = QtWidgets.QMenu("File", self.menuBar) #add a menu named File to the menuBar

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #ACTIONS IN MENU
    #FILE ACTIONS
    def addFileActionsToMenu(self):
        self.openFileAction = self.menuFile.addAction('Open') #make a new action called oprnFileAction and add it to menuFile
        self.openFileAction.triggered.connect(lambda: self.searchFileEventHandler())

        #do the same with the following with different var names and labels
        self.submitFileAction = self.menuFile.addAction('Submit')
        self.submitFileAction.triggered.connect(lambda: self.storeData()) #if it is triggered call to store data
        self.submitFileAction.setDisabled(True)


        self.exitFileAction = self.menuFile.addAction('Exit')
        self.exitFileAction.triggered.connect(self.quitTrigger) #if quit action clicked then call quit method

        self.menuBar.addAction(self.menuFile.menuAction()) #add the file action (dropdown) to the menuBar

    
    #FILE ACTION TRIGGERS
    #QUIT TRIGGER
    def quitTrigger(self):
        app.quit() #quits the application

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #MENU BAR SETTER / MUTATOR
    def menuBarSetter(self):
        self.setMenuBar(self.menuBar) #just a mutator / setter that sets the menu bar to self.menuBar

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #STATUS BAR
    #MAKE STATUS BAR
    def makeStatusBar(self):
        self.statusbar = QStatusBar() #makes a new object that an instance of QStatusBar

        self.statusBarSetter() #call to set the status bar

    #STATUS BAR SETTER
    def statusBarSetter(self):
        self.setStatusBar(self.statusbar) #sets the object to the status bar


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv) #make an instance of the application
    ui = Ui_MainWindow() #make an instance of the gui
    ui.show() #show the ui
    sys.exit(app.exec_()) #exit
