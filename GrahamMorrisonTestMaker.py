# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'StartingLook.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import os #for restarting the program


from PyQt5.QtWidgets import*
from PyQt5.QtWidgets import QApplication #to start
from PyQt5.QtWidgets import QMainWindow #provides a framework for building an application's user interface. 
from PyQt5.QtWidgets import QWidget #widget that pretty much all pyqt5 interfaces is based on as the central widget. It is what recieves events (ex. click, keydown)
from PyQt5.QtWidgets import QDesktopWidget #gives access to methods to get centre point of desktop

from PyQt5.QtWidgets import QAction 

from PyQt5.QtWidgets import QStatusBar
from PyQt5.QtWidgets import QMenuBar

class Ui_MainWindow(QMainWindow):
    '''
    QMainWindow Layout
    ______________________________________
   |__Menu Bar____________________________| #dropdown menu selections file, edit, etc
   |_______________ToolBars_______________| #makes buttons that give users access to functions, typcially just visual buttons for menu bar quick access
   |   __________Dock Windows__________   | #creates side view next to the central widget
   |  |                                |  |
   |  |                                |  |
   |  |          Cental Widget         |  | #the main widget, which is almost always QWidget to recieve the user's inputs
   |  |                                |  |
   |  |________________________________|  |
   |______________________________________|
   |___Status Bar_________________________| #can add temperary or permanent messages
    '''
    def __init__(self):
        super().__init__() #initialize the QMainWindow
        self.windowTitleSetter('New Test*') #call to name the default

        self.resize(597, 800) #set default size

        self.numQuestionsCreated = 0 #track the number of questions made

        self.createArrays() #creates arrays to track new instances of variables so specific instance variables can be referenced to store data

        self.makeCentralWidget() #make the central widget and central layout
        self.makeCentralScroll() #calls to make central layout able to scroll
        self.addToCentralScroll() #add the content inside of the scroll area

        self.makeMenuBar() #call to make menuBar
        self.makeStatusBar() #call to make status bar

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SET WINDOW TITLE
    def windowTitleSetter(self, title):
        self.setWindowTitle(title) #name the mainWindow with the specified title

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #CREATE ARRAYS
    def createArrays(self):
        self.questionInputLine = [] #needs to get the text from each input line when saving
        self.weightingBoxArray = [] #needs to get the weighting box from each scroll box when saving

        self.questionFormLayout = [] #store which form

        self.questionGridLayout = [] #store which grid layout
        self.addAnotherOptionBtn = [] #same for options

        self.questionOptionsArray = [] #to store options of a multi choice or poss ans

        self.checkBoxArray = [] #needs to store if check boxes are check or not

        self.questionType = [] # in order to be able to support the different layouts we need to keep track of the which type each question is
        self.questionTypeIndex = []  # the index of the particular question type

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #Central Widget
    def makeCentralWidget(self):
        self.centralWidget = QWidget() #define qWidget as the central widget, (accepts input)
        self.verticalLayoutForScroll = QtWidgets.QVBoxLayout(self.centralWidget) #make a verticle layout so the scrollArea widget can be placed in a layout, (needs to be entire, so this will only contain one container)
    
    #Scroll vert. layout which is actual main layout
    def makeCentralScroll(self):
        self.scrollArea = QtWidgets.QScrollArea(self.centralWidget) #set the central Qwidget to a scroll area which allows for the user to scroll if window is too small
        self.scrollArea.setWidgetResizable(True) #allow for the scroll area to be resized... necessary as adding more into the scroll area
        #now there a scroll area inside of the uppermost vertical layout that will recieve input scroll input from central widget, Qwidget

        self.scrollAreaWidgetContents = QtWidgets.QWidget() #defining what is in scroll area... which is the QWidget, which accepts user input, however Qwidget still has to be defined as central above to receive user input for the scroll
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 577, 207)) #set intial geometry of scroll area

        self.mainVerticalLayout = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents) #now need to put not technically the main layout, but the layout everything is going to be placed in since everything has to be inside the scroll area.
    
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #ADD TO SCROLL CONTENTS
    def addToCentralScroll(self):
        #now add the contents to the mainVert.layout
        self.emailInput() #add email input line
        self.makeTitleInput() #add the title input
        self.makeQuestionButtons() #add the question making buttons
        self.addScrollContentsToScrollWidget() #updates the contents from the object to the widget
    
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SCROLL COTENTS
    #EMAIL INPUT
    def emailInput(self):
        self.horizontalEmailLayout = QtWidgets.QHBoxLayout() #make a new horizontal layout
        
        self.label = QtWidgets.QLabel('Enter Your Email Here:',self.scrollAreaWidgetContents) #make a new label
        self.horizontalEmailLayout.addWidget(self.label) #add it to the email vert layout
        
        self.emailInputLine = QtWidgets.QLineEdit(self.scrollAreaWidgetContents) #make a new line edit
        self.horizontalEmailLayout.addWidget(self.emailInputLine) #add it to horizontal email layout

        self.mainVerticalLayout.addLayout(self.horizontalEmailLayout) #add the email horizontal layout to the vertical layout so it looks like... T - top is horizontal, downwards part is vertical layout
    
    #LINE EDIT FOR TITLE
    def makeTitleInput(self):
        self.titleLine = QtWidgets.QLineEdit('Enter the Title of the Test Here', self.scrollAreaWidgetContents) #make a new line edit
        self.titleLine.setStyleSheet("font: bold") #make it bold

        self.mainVerticalLayout.addWidget(self.titleLine) #add the lineEdit to the vertical layout
    
    #ADD NEW QUESTION BUTTONS
    def makeQuestionButtons(self):
        self.newMultiButton = QtWidgets.QPushButton('New Multiple Choice Question', self.scrollAreaWidgetContents) #from the QtWidgets library use push button to make a new button with the string as its text
        self.mainVerticalLayout.addWidget(self.newMultiButton) #add that button to the main vertical layout
        self.newMultiButton.clicked.connect(lambda:  self.makeNewQuestion('MC')) #if that button is clicked, call the method that makes the question

        self.newShortAnsButton = QtWidgets.QPushButton('New Short Answer Question', self.scrollAreaWidgetContents) #do the same for the short answer button
        self.mainVerticalLayout.addWidget(self.newShortAnsButton)
        self.newShortAnsButton.clicked.connect(lambda:  self.makeNewQuestion('SA'))

        self.newLongAnsButton = QtWidgets.QPushButton('New Long Answer Question', self.scrollAreaWidgetContents) #do the same for a long answer button
        self.mainVerticalLayout.addWidget(self.newLongAnsButton)
        self.newLongAnsButton.clicked.connect(lambda:  self.makeNewQuestion('LA'))

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SCROLL SETTER THAT ADDS CONTENTS TO WIDGET
    def addScrollContentsToScrollWidget(self):
        self.scrollArea.setWidget(self.scrollAreaWidgetContents) #add the contents (ex. buttons, line edit) to the scroll area
        self.verticalLayoutForScroll.addWidget(self.scrollArea) #add the scroll area to the veritcal layout
        self.setCentralWidget(self.centralWidget) #now that scroll has its contents, contents need to interact and receive input, so set the central widget to Qwidget

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #MAKE MENUBAR
    def makeMenuBar(self):
        self.menuBar = QMenuBar() #make a new menubar
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 602, 21)) #set default size

        self.addMenus() #add menus to the menubar
        self.addSecondaryMenus() #add secondary menus (ex. when you hover it gives more options)
        self.menuBarSetter() #call the mutator / setter to set it

        self.addFileActionsToMenu() #add the File actions (essentially buttons) in the menu
        self.addEditActionsToMenu() #add the Edit actions (essentially buttons) in the menu
    
    #MENUS
    def addMenus(self):
        self.menuFile = QtWidgets.QMenu("File", self.menuBar) #add a menu named File to the menuBar
        self.menuEdit = QtWidgets.QMenu("Edit", self.menuBar) #add a menu named Edit to the menuBar

    #SECONDARY MENUS
    def addSecondaryMenus(self):
        self.editMenuNewQuestion = QtWidgets.QMenu("New Question", self.menuEdit) #add an option to the editMenu called New Question

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #ACTIONS IN MENU
    #FILE ACTIONS
    def addFileActionsToMenu(self):
        self.newFileAction = self.menuFile.addAction('New') #make a new action called newFileAction and add it to menuFile
        self.newFileAction.triggered.connect(self.newFileTrigger)

        #do the same with the following with different var names and labels

        self.saveFileAction = self.menuFile.addAction('Save')
        self.saveFileAction.setShortcut('Ctrl+S') #sets a shortcut to the file save to control s
        self.saveFileAction.triggered.connect(self.saveTrigger) #if action called then call method

        self.saveAsFileAction = self.menuFile.addAction('Save As')
        self.saveAsFileAction.triggered.connect(self.saveAsTrigger)

        self.exitFileAction = self.menuFile.addAction('Exit')
        self.exitFileAction.setShortcut('Ctrl+E') #sets a shortcut to the file exit file

        self.exitFileAction.triggered.connect(self.quitTrigger) #if quit action clicked then call quit method

        self.menuBar.addAction(self.menuFile.menuAction()) #add the file action (dropdown) to the menuBar
    
    #FILE ACTION TRIGGERS
    def saveAsTrigger(self):
        try:
            self.filename = self.getFileName()
            if self.filename == '': #if they didnt selected a file
                return #return cancelling the action
            else: #otherwise
                self.windowTitleSetter(str(self.filename)) #set the window title to the save
                self.saveTrigger() #save the program by calling save Trigger
        except ValueError:
            print("dont crash")
            return

        # we have a filename, lets call the Save routine and pass it the filename

    def getFileName(self):
        qfd = QFileDialog()
        title = "Save Test As ... "
        path = ""
        filter = "Text Files(*.txt)"
        fname = QFileDialog.getSaveFileName(qfd, title, path , filter)
        return fname[0]

    #FILE TRIGGER
    def newFileTrigger(self):
        #self.saveTrigger() #save the 
        os.execl(sys.executable, sys.executable, *sys.argv) #restarts the app
        
    #QUIT TRIGGER
    def quitTrigger(self):
        app.quit() #quits the application

    #EDIT ACTIONS
    def addEditActionsToMenu(self):
        self.actionMultipleChoice = self.editMenuNewQuestion.addAction('Multiple Choice') #make a new action under the secondary menu new question
        self.actionMultipleChoice.triggered.connect(lambda: self.makeNewQuestion('MC')) #if action called, call the make multi choice method

        self.actionShortAnswer = self.editMenuNewQuestion.addAction('Short Answer')
        self.actionShortAnswer.triggered.connect(lambda: self.makeNewQuestion('SA')) #if action called, call the make short ans method

        self.actionLongAnswer = self.editMenuNewQuestion.addAction('Long Answer')
        self.actionLongAnswer.triggered.connect(lambda: self.makeNewQuestion('LA')) #if action called, call

        self.menuEdit.addAction(self.editMenuNewQuestion.menuAction()) #add the new question secondary menu to the edit menu

        self.menuBar.addAction(self.menuEdit.menuAction()) #add the Edit action (dropdown) to the menuBar

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #MENU BAR SETTER / MUTATOR
    def menuBarSetter(self):
        self.setMenuBar(self.menuBar) #just a mutator / setter that sets the menu bar to self.menuBar

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #STATUS BAR
    #MAKE STATUS BAR
    def makeStatusBar(self):
        self.statusbar = QStatusBar() #makes a new object that an instance of QStatusBar

        self.statusBarSetter() #call to set the status bar

    #STATUS BAR SETTER
    def statusBarSetter(self):
        self.setStatusBar(self.statusbar) #sets the object to the status bar

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#QUESTION METHODS    
    #MAKE THE GROUP BOX
    def makeGroupBox(self):
        self.questionNumber = ("Question " + str(self.numQuestionsCreated) + ":") #make instance variable that is string stating which question it is
        self.groupBox = QtWidgets.QGroupBox(self.questionNumber, self.centralWidget) #make a new group Box, first is the titleof the groupBox which is the question number
        self.groupBoxVerticalLayout = QtWidgets.QVBoxLayout(self.groupBox) #create a vertical layout inside the groupbox

        self.questionFormLayout.append('Empty Layout') #add another index to the list
        self.questionFormLayout[(self.numQuestionsCreated-1)] = QtWidgets.QFormLayout() #create a form layout to be later be added to the vertical layout - form layout adds left to right for 2 spaces at a given index where the index is its vertical order

    #ADD QUESTION TO GROUP BOX
    def makeQuestion(self, order):
        self.questionInputLine.append('Empty') #add another string element to the list
        self.shortAnsQuestionPromtLabel = QtWidgets.QLabel("Enter your question here:", self.groupBox) #create a new label that belongs to the groupBox
        self.questionFormLayout[(self.numQuestionsCreated-1)].setWidget(order, QtWidgets.QFormLayout.LabelRole, self.shortAnsQuestionPromtLabel) #add that label to the form layout, order being whether its first 2nd etc

        defaultText = "This is what students will see"
        self.questionInputLine[(self.numQuestionsCreated-1)] = QtWidgets.QLineEdit(defaultText, self.groupBox) #create a new line edit that belongs to the groupBox, string arg is the default text... however line is in an array so each instance can be accessed base off the question
        self.questionFormLayout[(self.numQuestionsCreated-1)].setWidget(order, QtWidgets.QFormLayout.FieldRole, self.questionInputLine[(self.numQuestionsCreated-1)]) #add that line edit to the form layout, order being whether its first 2nd etc

    #ADD WEIGHTING TO GROUP BOX
    def makeWeighting(self, order):
        self.weightingBoxLabel = QtWidgets.QLabel("Weighting", self.groupBox) #create a new label that belongs to the groupBox
        self.questionFormLayout[(self.numQuestionsCreated-1)].setWidget(order, QtWidgets.QFormLayout.LabelRole, self.weightingBoxLabel) #add that label to the form layout, order being whether its first 2nd etc

        self.weightingBoxArray.append('Empty') #add another element to the weighting box each time called
        self.weightingBoxArray[(self.numQuestionsCreated-1)] = QtWidgets.QSpinBox(self.groupBox) #make a new spinbox that belongs to the groupbox, that is stored to the question # - 1 index of the array that stores weighting boxes
        self.weightingBoxArray[(self.numQuestionsCreated-1)].setFrame(True) #gives the spinbox a frame because it defaults without one
        self.weightingBoxArray[(self.numQuestionsCreated-1)].setMinimum(1) #set the box min to 1

        self.questionFormLayout[(self.numQuestionsCreated-1)].setWidget(order, QtWidgets.QFormLayout.FieldRole, self.weightingBoxArray[(self.numQuestionsCreated-1)]) #add the spin box to the form layout, order being whether its first 2nd etc

    #ADD A LINE TO THE GROUP BOX
    def makeSpacingLine(self, order):
        self.line = QtWidgets.QFrame(self.groupBox) #make an instance of QFrame that belongs to the groupBox
        self.line.setFrameShape(QtWidgets.QFrame.HLine) #set Q frame shape to a horizontal line
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken) # changes line style to make it more opaque and more of a shadow than bold black line
        
        self.questionFormLayout[(self.numQuestionsCreated-1)].setWidget(order, QtWidgets.QFormLayout.FieldRole, self.line) #add the line to the form in its given order
        

    #-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # BUILD QUESTION
    def makeNewQuestion(self,whatQuestionType):
        self.optionsMade = 0 #define an instance variables of the number of answers made for creating extra answers
        self.numQuestionsCreated += 1 #add that another question has been made

        self.questionType.append(whatQuestionType)
        self.questionTypeIndex.append(self.numQuestionsCreated)

        self.nestedCheckBoxSetArray = [] #to track what options are in given question
        self.nestedOptionsSet = []
        self.questionOptionsArray.append('New option array set')
        self.checkBoxArray.append('New Check Box Array Set') #add an element to checkBoxArray, so a list can be set to the index indicating that it is another question
        
        self.makeGroupBox() #make the group box
        self.addToGroupBoxForm() #add the elements to the group box, ex. buttons labels etc
        self.addQuestionToTest() #add the group box to the test

    #CALL METHODS TO ADD WIDGETS TO ADD TO THE GROUP BOX
    def addToGroupBoxForm(self):
        self.makeQuestion(0) #call to add the features to the group box with the arguement being the order in the form
        self.makeWeighting(1)
        self.makeSpacingLine(2)

    #MULTICHOICE OPTION ROW
    def addQuestionOption(self, order, whatQuestion, firstOption):
        print('adding another ' + self.questionType[whatQuestion] + ' option to question ' + str(whatQuestion))

        self.nestedOptionsSet = []
        self.nestedCheckBoxSetArray = []
        if not firstOption:     # if this is the first option then it will interpret questionOptionsArray as a string, so don't do it
            self.nestedOptionsSet = self.questionOptionsArray[whatQuestion]  #add other defined options to the list.
            self.nestedCheckBoxSetArray = self.checkBoxArray[whatQuestion]
        self.nestedOptionsSet.append('New Option')
        self.nestedCheckBoxSetArray.append('Empty') #add another element to the set array

        nestedSize = len(self.nestedOptionsSet)

        # ----- add and format option labels based on question type 
        if (self.questionType[whatQuestion]) == 'MC':
            self.optionLabelText = ("Option "+ str(nestedSize) +":") #insert the variable into the label text 
        elif (self.questionType[whatQuestion]) == 'SA':
            self.optionLabelText = ("Correct Answer :") 
        else:
            self.optionLabelText = (" ") 

        self.optionLabel = QtWidgets.QLabel(self.optionLabelText, self.groupBox) #make a new label that belongs to the groupBox whos text is optionLabelText
        self.questionGridLayout[whatQuestion].addWidget(self.optionLabel, nestedSize-1, 0, 1, 1) #add the new label to the multichoice grid layout, on the left side (arg. after order) and row = to the inputted parameter order
        
        # ---- add checkboxes if required
        checkBoxText = "Correct?"
        self.nestedCheckBoxSetArray[nestedSize - 1] = QtWidgets.QCheckBox(checkBoxText,self.groupBox) #make a new label that belongs to the groupBox whos text asks if it is correct?
        if (self.questionType[whatQuestion]) != 'MC':
            self.nestedCheckBoxSetArray[nestedSize - 1].setVisible(False) # if not a multiple choice question, then hide the checkbox

        self.questionGridLayout[whatQuestion].addWidget(self.nestedCheckBoxSetArray[(nestedSize-1)], nestedSize-1, 1, 1, 1) #add the new check box to the multichoice grid layout, in the middle (arg. after order) and row = to the inputted parameter order
        self.checkBoxArray[whatQuestion] = self.nestedCheckBoxSetArray #update the question index of the 2d array to the new contents
        
        # ---- add the lineEdit
        self.nestedOptionsSet[nestedSize -1] = QtWidgets.QLineEdit(self.groupBox)
        self.questionGridLayout[whatQuestion].addWidget(self.nestedOptionsSet[nestedSize - 1], nestedSize-1, 2, 1, 1) #add the new label to the multichoice grid layout, on the left side (arg. after order) and row = to the inputted parameter order
        if (self.questionType[whatQuestion]) == 'LA':
            self.nestedOptionsSet[nestedSize -1].setVisible(False)  # if this is a long form answer, we don't need to collect correct answers

        self.questionOptionsArray[whatQuestion] = self.nestedOptionsSet #do the same for the 
       

    #ADD LAYOUTS AFTER FORM
    def addQuestionToTest(self):
        self.groupBoxVerticalLayout.addLayout(self.questionFormLayout[(self.numQuestionsCreated-1)]) #add the form Layout to the group box layout

        self.questionGridLayout.append('New Layout')

        self.questionGridLayout[self.numQuestionsCreated-1] = QtWidgets.QGridLayout() #now that the form layout has been added, make grid layout to later be added to vertical layout

        # self.nestedMultiChoiceOption = []

       # if (self.questionType[self.numQuestionsCreated -1]) != 'LA':              # don't create an answer  text entry field for long answer questions (not required)
        self.addQuestionOption(0, (self.numQuestionsCreated -1),1) #add an option row to the new grid layout
        if (self.questionType[self.numQuestionsCreated -1]) == 'MC':
            self.addQuestionOption(1, (self.numQuestionsCreated -1),0) #call again to start with 2 options (if multiple choice)

        self.groupBoxVerticalLayout.addLayout(self.questionGridLayout[(self.numQuestionsCreated - 1)]) #add the grid layout to the group box layout

        self.addAnotherOptionButton(self.questionType[self.numQuestionsCreated -1]) #now call to add the extra answer button to the form so it will be at the bottom of the group box

        self.mainVerticalLayout.addWidget(self.groupBox) #add the group box to the main vertical layout

    def addAnotherOptionButton(self, qType):
        self.addAnotherOptionBtn.append('Empty') #add another element to the array so it can be changed each time called

        if qType == 'SA':
            buttonText = "Add additional correct answer to question "
        elif qType == 'LA':
            buttonText = "(no extra options)"
        else:
            buttonText = "Add option to question "
        
        self.addAnotherOptionBtn[(self.numQuestionsCreated-1)] = QtWidgets.QPushButton(buttonText + str(self.numQuestionsCreated), self.groupBox) #create a new button that belongs to the groupBox, needs to be a part of a list so it can be referenced specifically when that button is pushed
        if qType == 'LA':
            self.addAnotherOptionBtn[(self.numQuestionsCreated-1)].setVisible(False) #create a new button that belongs to the groupBox, needs to be a part of a list so it can be referenced specifically when that button is pushed
        else:
            self.addAnotherOptionBtn[(self.numQuestionsCreated-1)].clicked.connect((lambda checked, qNum = (self.numQuestionsCreated-1) : self.addQuestionOption(self.optionsMade,qNum,0))) #if the add button is clicked call to make another answer, and the order of the answer will be the order of the current answer plus each answer that has been set for this quesion.
    
        self.groupBoxVerticalLayout.addWidget(self.addAnotherOptionBtn[(self.numQuestionsCreated-1)] ) #add the widget to the vertical layout instead so its always at the bottom
        
        # above also needs to know what question the button is referring to so passes that as arg too which requires lambda checked, so the buttons will have different connections

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #SAVE ACTION / STORING
    def saveTrigger(self):
        #first clear all previous save data
        #check if it has been save as first...
        try:
            print("i got here")
            self.filename = self.getFileName()
            
            title = self.getLineText(self.titleLine) #make var title that is the returtned line text of the line edit for the title
            print(title)
            #CRASHES ON NO INPUTF
            email = self.getLineText(self.emailInputLine) #make var that is the returned text of the line edt for the email input
            print(email)
            questionsDataList = self.retreiveLineData() #
            weightingDataList = self.retreiveWeightingData()
            checkBoxData = self.retreiveCheckBoxData()
            answerData = self.retreiveAnswerData()

            #now save question data to a file
            memoryFile = open(str(self.filename), "a") #also going to open the file / make it if it has not been made and (a for) append
            memoryFile.truncate(0) #truncate erases content of text file

            memoryFile.write(title) #write the variable to the file... same for others with repsective variables
            memoryFile.write('|') #add spacer between each variable
            memoryFile.write(email) 
            memoryFile.write('|') #add spacer between each variable
            memoryFile.write(str(self.questionType)) #add a str of the question type
            memoryFile.write('|') #add spacer between each variable
            memoryFile.write(str(questionsDataList)) #and convert other lists into str too to write
            memoryFile.write('|') #add spacer between each variable
            memoryFile.write(str(weightingDataList))
            memoryFile.write('|') #add spacer between each variable
            memoryFile.write(str(answerData)) #is also option data
            memoryFile.write('|') #add spacer between each variable
            memoryFile.write(str(checkBoxData))
            
            memoryFile.close() #close file

            #STATUS BAR SHOW MESSAGE
            self.statusBar().showMessage('Saved to ' + str(self.filename), 5000) #display a message
        except ValueError:
            print("you no pick")
            return


        
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #RETURNING ALL QUESTIONS
    def retreiveLineData(self):
        linesAsStrings = [] #make a new empty list to store the strings
        for LineEdit in self.questionInputLine: #for each line instance in the array
            linesAsStrings.append(self.getLineText(LineEdit)) #call the getter to return its text than append that to the 
        
        return linesAsStrings #return the list
    
    #---
    def getLineText(self, lineEditInst):
        return lineEditInst.text() #return the text of the instance of the line edit
    
    #---
    #RETURNING ALL SPINBOXES
    def retreiveWeightingData(self):
        weightingsAsInts = [] #make new list to store to
        for WeightingBox in self.weightingBoxArray: #for each obj in the list
            weightingsAsInts.append(self.getWeightingInt(WeightingBox)) #call the getter to return its int val then append that to the list.
        
        return weightingsAsInts #then return the list with the ints
    
    def getWeightingInt(self, weightingBoxInst):
        return weightingBoxInst.value() #return the int value of the inst of the box

    #---
    #RETURN ALL CHECKBOXES
    def retreiveCheckBoxData(self):
        checkBoxTrueOrFalse = [] #make a list to append to
        for checkBoxSet in self.checkBoxArray: #for each list in the the 2d array
            nestedCheckBoxSet = [] #make a list to store to / redfine the list
            for checkBoxObj in checkBoxSet: #for each check box obj in that list
                nestedCheckBoxSet.append(self.checkIfBoxChecked(checkBoxObj)) #append it the box obj is check or not to the nested check box set

            checkBoxTrueOrFalse.append(nestedCheckBoxSet) #now that nestedCheckBoxSet has been appended to, append that list to the main list

        return checkBoxTrueOrFalse #return the list

    def checkIfBoxChecked(self, checkBoxInst):        
        return checkBoxInst.isChecked() #returns true or false if it is checked

    #---
    #RETURN ALL ANSWERS
    def retreiveAnswerData(self): #questionsOptionsArray
        answerDataAsString = []
        for answerSet in self.questionOptionsArray: #for each list in the 2d array
            nestedAnswerSet = [] #make a list to store to
            for lineEditObj in answerSet: #for each line edit in the list
                nestedAnswerSet.append(self.getLineText(lineEditObj)) #get the text of the line edit and append it to the nested answer set list
            
            answerDataAsString.append(nestedAnswerSet) #then append the the nested list into the main list

        return answerDataAsString #return the list


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv) #make an instance of the application
    ui = Ui_MainWindow() #make an instance of the 
    ui.show()
    sys.exit(app.exec_())
